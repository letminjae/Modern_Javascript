# 실행 컨텍스트

> 자바스크립트의 동작 원리를 담고 있는 핵심 개념

- `스코프를 기반`으로 `식별자와 식별자에 바인딩된 값을 관리하는 방식`과 `호이스팅이 발생하는 이유`, `클로저의 동작 방식`, 그리고 `태스트 큐와 함께 동작하는 이벤트 핸들러`와 `비동기 처리의 동작 방식`을 이해할 수 있음

<br />
<br />

# 소스코드의 타입
| 소스코드의 타입 | 설명 |
| --- | --- |
|전역 코드(global code)	| `전역에 존재하는 소스코드`를 말한다. 전역에 정의된 함수, 클래스 등의 내부 코드는 포함되지 않는다.|
|함수 코드(function code) | `함수 내부에 존재하는 소스코드`를 말한다. 함수 내부에 중첩된 함수, 클래스 등의 내부 코드는 포함되지 않는다.|
|eval 코드(eval code) | 빌트인 전역함수인 `eval함수에 인수로 전달되어 실행되는 소스코드`를 말한다.|
|모듈 코드(module code)	| `모듈 내부에 존재하는 소스코드`를 말한다. 모듈 내부의 함수, 클래스 등의 내부 코드는 포함되지 않는다.|

- 전역 코드
    - 전역 코드는 전역 변수를 관리하기 위해 `최상위 스코프인 전역 스코프를 생성`해야 함
    - var 키워드로 선언된 전역 변수와 함수 선언문으로 정의된 전역 함수를 전역 객체의 프로퍼티와 메서드로 바인딩하여 연결 
    - 이를 위해 전역 코드가 평가되면 전역 실행 컨텍스트가 생성.

- 함수 코드 
    - 함수코드는 `지역 스코프를 생성`하고 `지역 변수, 매개변수, arguments객체를 관리`
    - 생성한 지역 스코프를 전역 스코프에서 시작하는 스코프 체인의 일원으로 연결
    - 이를 위해 함수 코드가 평가되면 함수 실행 컨텍스트가 생성

- EVAL 코드
    - eval코드는 `strict mode`에서 자신만의 독자적인 스코프를 생성
    - 이를 위해 eval코드가 평가되면 eval실행 컨텍스트가 생성

- 모듈 코드
    - 모듈 코드는 `모듈별로 독립적인 모듈 스코프를 생성`
    - 이를 위해 모듈 코드가 평가되면 모듈 실행 컨텍스트가 생성

> 자바스크립트 엔진은 소스코드를 2개의 과정으로 나누어 처리함. `소스코드의 평가`, `소스코드의 실행`

- 소스코드의 평가
    - 실행 컨텍스트를 생성
    - 변수, 함수등의 선언문 실행
    - 생성된 변수나 함수 식별자를 키로 실행 컨텍스트가 관리하는 스코프(렉시컬 환경의 환경 레코드)에 등록

- 소스코드의 실행
    - 선언문을 제외한 소스코드가 순차적으로 실행(런타임)
    - 실행에 필요한 정보(변수나 함수의 참조)를 실행 컨텍스트가 관리하는 스코프에서 검색해서 취득
    - 변수 값의 변경등 실행 결과는 다시 실행 컨텍스트가 관리하는 스코프에 등록

```jsx
var x;
x = 1;

//소스코드의 평가 : 변수 선언문 var x 를 실행 후 실행 컨텍스트가 관리하는 스코프에 등록, undefined를 뱉어냄

//소스코드의 실행 : var x는 이미 평가에서 실행완료했으니, x = 1 을 할당. 이때 x의 변수에 값을 할당하고 위해 먼저 x 변수가 선언되었는지 확인. 등록되어있으니 할당 결과를 실행 컨텍스트에 등록 후 관리
```

<br />
<br />

## 실행 컨텍스트의 역할

```jsx
const x = 1;
function foo(a) {
  const x = 10;
  console.log(a + x); // 함수 실행 시 console 식별자는 스코프체인을 통해 검색
  // log 프로퍼티도 console 객체의 프로토타입 체인을 통해 검색 됨
}
foo(100); // 전역 코드 실행이 멈추고 함수 코드 평가 + 함수 코드 실행
console.log(x); // 다시 전역 코드 실행이 이어짐
```

- 코드가 실행되려면 `스코프를 구분하여 식별자와 바인딩 된 값이 관리`되어야 함
- 중첩 관계에 의해 `스코프 체인을 형성하여 식별자를 검색`할 수 있어야 함
- `전역 객체의 프로퍼티도 전역 변수처럼 검색`할 수 있어야 함

- 함수 호출이 종료되면 함수 호출 이전으로 되돌아가기 위해 현재 실행 중인 코드와 이전에 실행하던 코드를 구분하여 관리해야 한다.
- 코드가 실행되려면

  - `스코프, 식별자, 코드 실행 순서 등의 관리가 필요`하다
  - 이 모든것을 관리하는 것이 `실행 컨텍스트`

- 실행 컨텍스트는

  - 소스코드를 실행하는 데 필요한 환경을 제공하고
  - 실행 결과를 실제로 관리하는 영역이다

> 실행 컨텍스트는 `식별자(변수, 함수 등의 이름)를 등록하고 관리하는 스코프와 코드 실행 순서를 구현한 내부 메커니즘` => 모든 코드는 실행 컨텍스트를 통해 실행되고 관리

- `식별자와 스코프`는 `렉시컬 환경`으로 관리
- `코드 실행 순서`는 `실행 컨텍스트 스택`으로 관리

<br />
<br />

### 실행 컨텍스트 스택

```jsx
const x = 1;
function foo() {
  const y = 2;
  function bar() {
    const z = 3;
    console.log(x + y + z);
  }
  bar();
}
foo();
```
1. 전역 코드 평가
- 전역 코드를 실행하기 전에 전역 코드 평가 과정을 거쳐 준비를 한다.
- 선언문만 먼저 실행한다. 
```
const x; 
const y;
```
- 생성된 `전역 변수와 전역 함수가 실행 컨텍스트가 관리하는 전역 스코프에 등록`된다.
- 이때 var키워드로 선언된 `전역 변수와 함수 선언문으로 정의된 전역 함수는 전역 객체의 프로퍼티와 메서드`가 된다.(브라우저는 window객체의 프로퍼티와 메서드가 된다.)

2. 전역 코드 실행
- 평가 과정이 끝나면 `런타임이 시작되어 코드가 순차적으로 실행`된다.
- 전역 변수에 값이 할당되고 `함수가 호출`된다.x = 1; y = 1;
- `함수가 호출`되면 `전역코드의 실행을 중단`하고 코드 실행 순서를 변경하여 `함수 내부로 진입`한다.

```
foo(100);
```

3. 함수 코드 평가
- `함수 내부로 진입하면 내부의 문들을 실행하기 전에 함수 코드 평가 과정`을 거치며 준비한다.
- `매개변수(a)와 지역 변수 선언문이 먼저 실행`되고 실행 컨텍스트가 관리하는 `지역 스코프에 등록`된다.
- `arguments객체가 생성`되어` 지역 스코프에 등록`되고, `this바인딩`도 결정된다.

4. 함수 코드 실행
- 평가 과정이 끝나면 런타임이 시작되어 코드가 순차적으로 실행된다.
- 매개변수와 지역 변수에 값이 `할당`되고 console.log(a + x + y);메서드가 호출된다. 
- console 식별자는 스코프 체인을 통해 검색한다.(현재 스코프에 없으면 상위 스코프로 올라가서 검색)

위와 같이 동작을 관리하기 위해 실행 컨텍스트가 필요하다.

<br />
<br />


# 렉시컬 환경(Lexical Environment)

> 식별자와 식별자에 바인딩된 값, 그리고 상위 스코프에 대한 참조를 기록하는 자료구조로,실행 컨텍스트를 구성하는 컴포넌트

> 렉시컬 환경은 스코프와 식별자를 관리한다.

- 실행 컨텍스트 스택 : 코드의 실행 순서를 관리
- 렉시컬 환경 : 스코프와 식별자를 관리

- 렉시컬 환경

  - 키-값을 갖는 `객체 형태의 스코프(전역, 함수, 블록 스코프)를 생성하여 식별자를 키로 등록`하고
  - `식별자에 바인딩된 값을 관리`
  - `스코프를 구분하여 식별자를 등록하고 관리`하는 `저장소 역할`을 하는 렉시컬 스코프의 실체

#### 렉시컬 환경은 다음 두 개의 컴포넌트로 구성

1. 환경 레코드(Environment Record)
   - 스코프에 포함된 식별자를 등록
   - 등록된 식별자에 바인딩된 값을 관리
   - 소스코드의 타입에 따라 관리하는 내용에 차이가 있다

2. 외부 렉시컬 환경에 대한 참조(Outer Lexical Environment Reference)
   - 상위 스코프를 가리킨다
   - 외부 렉시컬 환경에 대한 참조를 통해 단방향 링크드 리스트, 스코프 체인을 구현한다

<br />
<br />

# 실행 컨텍스트의 생성과 식별자 검색 과정

```jsx
var x = 1;
const y = 2;
function foo (a) {
  var x = 3;
  const y = 4;
  function bar (b) {
    const z = 5;
    console.log(a + b + x + y + z);
}
  bar(10);
}
foo(20); // 42
```

### 1. 전역 객체 생성

- 전역 객체는 `전역 코드가 평가되기 이전에 생성`.
- 빌트인 전역 프로퍼티와 빌트인 전역함수, 표준 빌트인 객체가 추가되며, 동작환경에 따라 클라이언트 사이드 Web API(DOM, BOM, Canvas, XMLHttpRequest, Web Stroage, Web Component, Web Worker등)또는 특정 환경을 위한 호스트 객체를 포함.

- 전역 객체도 Object.prototype을 상속 받는다. 즉, `전역 객체도 프로토타입 체인의 일원`
```jsx
// Object.prototype.toString
window.toString(); // -> "[object Window]"

window.__proto__.__proto__.__proto__.__proto__ === Object.prototype; // -> true
```

### 2. 전역 코드 평가

- 전역 코드 평가 순서
  - 전역 실행 컨텍스트 생성
  - 전역 렉시컬 환경 생성
    - 전역 환경 레코드 생성
      - 객체 환경 레코드 생성
        - `호이스팅` - undefined로 초기화
        - let, const -> Temporal Dead Zone -> 호이스팅은 되지만 에러를 발생시킴
      - 선언적 환경 레코드 생성
    - this 바인딩
    - 외부 렉시컬 환경에 대한 참조 결정

(1) `전역 실행 컨텍스트 생성`
- 전역 실행 컨텍스트를 생성하여 실행 컨텍스트 스택에 푸시한다.

(2) `전역 렉시컬 환경 생성`
- 전역 렉시컬 환경(Global Lexical Environment)을 생성하고 전역 실행 컨텍스트에 바인딩 한다.

(2-1) `전역 환경 레코드 생성`
- 전역 환경 레코드(Global Environment Record)는 전역 변수를 관리하는 전역 스코프
- 전역 객체의 빌트인 전역 프로퍼티와 빌트인 전역 함수
- 표준 빌트인 객체를 제공
- 전역 환경 레코드는 `객체 환경 레코드`와 `선언적 환경 레코드`로 구성

    - `객체 환경 레코드`
        - var키워드로 선언한 전역 변수와 함수 선언문으로 정의한 전역 함수
        - 빌트인 전역 프로퍼티와 빌트인 전역 함수
        - 표준빌트인 객체
        - var로 선언된 변수와 함수는 BindingObject를 통해 전역 객체의 프로퍼티와 메서드가 된다.
    - `선언적 환경 레코드`
        - let, const키워드로 선언한 전역 변수는 전역 객체의 프로퍼티가 되지 않고 개념적인 블록 내에 존재
        - window.y와 같이 참조할 수 없다.
        - 변수는 `선언 단계`와 `초기화 단계`가 분리되어 있다.
        - 일시적 사각지대(TDZ, Temporal Dead Zone)에 빠지게 된다.

(2-2) `this 바인딩`
- 전역 환경 레코드의 [[GlobalThisValue]] 내부 슬롯에 this가 바인딩된다.
- 참고로 전역 환경 레코드를 구성하는 `객체 환경 레코드`와 `선언적 환경 레코드`에는 `this바인딩이 없다.` `this바인딩은 전역 환경 레코드와 함수 환경 레코드에만 존재`한다.

(2-3) `외부 렉시컬 환경에 대한 참조 결정`
- 현재 평가 중인 소스코드를 포함하는 외부 소스코드의 렉시컬 환경, 즉 상위 스코프를 가리킨다.

### 3. 전역 코드 실행
- 전역 코드가 순차적으로 실행 된다.
- 변수 할당문이 실행되어 전역 변수 x, y에 값이 할당된다.

### 4. foo 함수 코드 평가
- 이제 foo(20);함수를 호출하기 직전의 상황.
- `foo 함수의 호출` => `전역 코드의 실행이 중단`, `제어권이 foo함수 내부로 이동`한다. 
- 이후 `함수 코드 평가 시작.`

(1) 함수 실행 컨텍스트 생성
- foo함수 실행 컨텍스트를 생성하고 실행 컨텍스트 스택에 푸시.

(2) 함수 렉시컬 환경 생성
- foo함수 렉시컬 환경을 생성하고 foo함수 실행 컨텍스트에 바인딩(연결)한다.

(2-1) 함수 환경 레코드 생성
함수 환경 레코드에는 매개변수, arguments객체, 함수 내부에서 선언한 지역 변수와 중첩 함수를 등록하고 관리한다.

(2-2) this 바인딩
함수 환경 레코드의 [[ThisValue]] 내부 슬롯에 this가 바인딩.
foo함수는 `일반 함수(메서드X)로 호출되었으므로 this는 전역 객체를 가리킨다.`

(2-3) 외부 렉시컬 환경에 대한 참조 결정
foo함수는 전역 코드에 정의된 함수이기 때문에 외부 렉시컬 환경 참조에는 전역 렉시컬 환경의 참조가 할당.

### 5. foo 함수 코드 실행
- 런타임 시작, foo함수의 코드가 순차적으로 실행.
- 매개변수에 인수가 할당되고(a에 10할당) 변수 할당문이 실행되어 지역변수 x,y에 각 3,4가 할당.
- bar함수 호출.

### 6. bar 함수 코드 평가
- 이제 `bar함수로 제어권이 이동` => `bar함수 코드를 평가하기 시작` => `실행 컨텍스트가 생성되고 스택에 추가`. 
- foo함수 와 동일하게 `bar 렉시컬 환경을 생성` => `환경 레코드 생성` => `this바인딩` => `외부 렉시컬 환경 참조를 할당` 순으로 평가.

### 7. bar 함수 코드 실행
- 런타임 시작, bar함수의 코드가 순차적으로 실행. 
- 매개변수에 인수가 할당(b에 10할당)되고 z에 5를 할당.
- console.log(a + b + x + y + z);가 실행

### 8. bar 함수 코드 실행 종료
- bar함수 코드에 더이상 실행할 코드가 없어 `bar함수 실행을 종료.` 
- 이때 실행 컨텍스트 스택에서 bar함수 실행 컨텍스트가 `팝되어 제거`, foo실행 컨텍스트가 실행중 컨텍스트가 된다.

### 9. foo 함수 코드 실행 종료
- bar함수가 종료되면 foo함수도 더이상 실행할 코드가 없으므로 `foo함수 코드의 실행도 종료`. 
- 이때 실행 컨텍스트 스택에서 foo함수 실행 컨텍스트가 `팝되어 제거`, 전역 실행 컨텍스트가 실행중인 실행 컨텍스트가 된다.

### 10. 전역 코드 실행 종료
- foo함수가 종료되면 전역 코드도 더이상 실행할 코드가 없으므로 전역 코드의 실행도 종료되고, `전역 실행 컨텍스트도 실행 컨텍스트 스택에서 제거`된다.

<br />
<br />

# 실행 컨텍스트와 블록 레벨 스코프

> var키워드로 선언된 변수는 오로지 `함수의 코드 블록만 지역 스코프로 인정하는 함수 레벨 스코프를 따른다.`

> 하지만 let,const키워드로 선언한 변수는 `모든 코드 블록(함수, if문, for문, while문, try/catch문 등)을 지역 스코프로 인정하는 블록 레벨 스코프를 따른다.`

```jsx
let x = 1;

if (true) {
  let x = 10;
  console.log(x); // 10
}

console.log(x); // 1
```

- 위 예제를 보면 if문의 코드 블록 내에서 let키워드로 변수가 선언되었다. 
- 따라서 if문의 코드 블록이 실행되면 if문의 코드 블록을 위한 블록 레벨 스코프를 생성해야 한다.
- 이를 위해 선언적 환경 레코드를 갖는 렉시컬 환경을 새롭게 생성하여 기존의 전역 렉시컬 환경을 교체한다.